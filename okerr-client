#!/usr/bin/python


import argparse
import requests
import sys
import os
import psutil
import time
import hashlib
import json

import logging
import logging.handlers

import evalidate

import socket
from socket import AF_INET, SOCK_STREAM, SOCK_DGRAM


log = logging.getLogger('Logger')
log.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address='/dev/log')
log.addHandler(handler)

version='1.6 (localcache)'

cachepath='/usr/local/etc/okerr-cache.json'

def update(textid,name,status,details=None,secret=None,
    method=None,error=None,urlprefix=None, verbose=False):

    r = None
    
    if not urlprefix:
        print "cannot update, url not given!"
        return
        
    url = urlprefix+'update'
    
    if verbose:
        print "{} {} {} ({})".format(textid,name,status,details)

    

    payload={'textid': textid, 'name':name, 'status': status, 
        'details': details, 'secret': secret, 'method': method,'error': error}

    if secret:
        secretlog="[secret]"
    else:
        secretlog="[nosecret]"
    start = time.time()
    try:
        r = requests.post(url, data=payload)
        if r.status_code==200:
            log.info('okerr send update OK textid:{}, {}={} {}'.\
                format(textid,name,status,secretlog))
        else:
            log.info('okerr update error {} \'{:.50}\' textid:{}, {}={} {}'.\
                format(r.status_code,r.text,textid,name,status,secretlog))
        if verbose:
            print "Request to URL {}:".format(r.request.url)
            print r.request.body
        
    except requests.exceptions.ConnectionError as e:
        log.info('okerr exception {} textid:{}, {}={} {}'.\
            format(str(e),textid,name,status,secretlog))
 
    if verbose:    
        if r:
            print r.content
        else:
            print "no reply, check log"
        print "took {} sec.".format(time.time() - start)

def pid2name(pid):
    for proc in psutil.process_iter():
        if proc.pid==pid:
            return proc.name()
    return ""

def getportstr(expr):
    ports=[]
    cc=[]
  
    if expr is None or expr=='':
        expr='True'

    AF_INET6 = getattr(socket, 'AF_INET6', object())

    proto_map = {
        (AF_INET, SOCK_STREAM): 'tcp',
        (AF_INET6, SOCK_STREAM): 'tcp6',
        (AF_INET, SOCK_DGRAM): 'udp',
        (AF_INET6, SOCK_DGRAM): 'udp6',
    }       
                    
    cc=[]

    for proc in psutil.process_iter():
        try:
            for c in proc.connections():
                if c.status=='LISTEN' or c.status=='NONE':
                    proto=proto_map[(c.family,c.type)]
                    crec = {}
                    crec['proto']=proto
                    crec['ip']=c.laddr[0]
                    crec['port']=c.laddr[1]
                    crec['name']=os.path.basename(proc.exe())

                    if not crec in cc:
                        cc.append(crec)
        except psutil.NoSuchProcess:
            pass

    node = evalidate.evalidate(expr)
    code = compile(node,'<usercode>','eval')
        
    for c in cc:
        if eval(code,{},c):
            clist=[c['name'],c['proto'],c['ip'],str(c['port'])]
            cstr=':'.join(clist)
            ports.append(cstr)
        else:
            pass

    return "\n".join(sorted(ports))


def getiarg(textid,name,iarg,secret,urlprefix='http://update.okerr.com/okerr/'):
    payload={'textid': textid, 'name':name,  
        'secret': secret, 'argname': iarg}

    
    url = urlprefix+'getpub'

    try:
        r = requests.post(url, data=payload)
        if r.status_code==200:
            if not 'urlcontent' in cache:
                cache['urlcontent']={}
            cache['urlcontent'][url]=r.content                
            return r.content
        else:
            log.error('okerr getiarg failed ({}): {}'.\
                format(r.status_code,r.content))
            try:
                cached = cache['urlcontent'][url]
                log.error('use cached value for url {} : {}'.format(url,cached))
                return cached
            except:
                log.error('no cache for url {}'.format(url))
                return ""            
        
    except requests.exceptions.ConnectionError as e:
        log.info('okerr getiarg exception {}'.\
            format(str(e)))
        try:
            cached = cache['urlcontent'][url]
            log.error('use cached value for url {} : {}'.format(url,cached))
            return cached
        except:
            log.error('no cache for url {}'.format(url))
            return ""            
 

### MAIN ### 

parser = argparse.ArgumentParser(description='okerr client. update/create indicators over HTTP.')
parser.add_argument('-i',dest='textid', help='project unique text id (not project name!)')
parser.add_argument('-n',dest='name', help='indicator name')
parser.add_argument('-s',dest='status', help="status. For heartbeat: 'OK' or 'ERR', for numerical N or N.NN (123, 36.6), or string for string match (static or dynamic)", nargs='+')
parser.add_argument('-d', metavar='details', dest='details',help='optional details')
parser.add_argument('-S', metavar='secret', dest='secret',help='optional secret')
parser.add_argument('-u', metavar='updateurl', dest='updateurl', default='http://update.okerr.com/okerr', help='update url')
parser.add_argument('-m', metavar='method', dest='method',default='heartbeat', help='checkmethod: heartbeat (default), numerical, streqs, streqd')
parser.add_argument('--prefix', help='prefix')
parser.add_argument('--version', help='print version', action='store_true')
parser.add_argument('-v', dest='verbose',action='store_true',help='verbose mode')



args = parser.parse_args()
#print "args:",args

print "status: ",args.status

if args.verbose:
    err = logging.StreamHandler(sys.stderr)
    log.addHandler(err)

if args.version:
    print version
    sys.exit(0)

if not args.textid:
    print "required project TextID (-i)"
    sys.exit(1)

# fix updateurl
if not args.updateurl.endswith('/'):
    args.updateurl+='/'

if args.prefix:

    # init/load cache
    try:
        with open(cachepath,"r") as f:
            cachejson = f.read()
            cache = json.loads(cachejson)
    except IOError:
        log.info('no cache, initialize')
        cache={}
    except ValueError as e:
        log.info('broken cache: {}, reinit'.format(e))
        cache={}
        
        
    if args.verbose:
        print "update all system indicators with prefix '{}'".format(args.prefix)
    # finish prefix with '.'
    if args.prefix.endswith(':'):
        prefix=args.prefix
    else:
        prefix=args.prefix+':'

    # alive
    update(args.textid, prefix+"heartbeat", 'OK', details=args.details,
        secret=args.secret, urlprefix=args.updateurl,verbose=args.verbose)
    
    # load average
    laarr = os.getloadavg()
    update(args.textid, prefix+"la1", laarr[0], details=", ".join(str(x) for x in laarr), 
        secret=args.secret, method='numerical|minlim=0|maxlim=0.8', urlprefix=args.updateurl,
        verbose=args.verbose)
    
    # number of logged in users
    #w=psutil.get_users()
    #ustr = " ".join(sorted(set(u.name for u in psutil.get_users())))
    #update(args.textid, prefix+"w", ustr, secret=args.secret, method='streqd', url=args.updateurl,verbose=args.verbose)


    # open ports
    portarg=getiarg(textid=args.textid,name=prefix+"ports",iarg='pub:arg',secret=args.secret)
    try:
        portstr=getportstr(portarg)
        update(args.textid, prefix+"ports", portstr, details=portstr, secret=args.secret, 
            method="streqd|pub:arg=not proto=='udp'", 
            urlprefix=args.updateurl,verbose=args.verbose)
    except (NameError,SyntaxError,ValueError) as e:
        if args.verbose:
            print "ERR: {}".format(str(e))
        update(args.textid, prefix+"ports", 'ERR', error=str(e),
        secret=args.secret, method="streqd|pub:arg=not proto=='udp'", urlprefix=args.updateurl,verbose=args.verbose)
  
    
    # number processes
    update(args.textid, prefix+"processes", len(psutil.pids()),
    details=len(psutil.pids()), secret=args.secret,
    method='numerical|minlim=0|maxlim=400',
    urlprefix=args.updateurl,verbose=args.verbose)
    
    for p in psutil.disk_partitions():
        usage = psutil.disk_usage(p.mountpoint)
        update(args.textid, prefix+"partition-"+p.mountpoint, usage.percent,
        details="{} {} {}%".format(p.device, p.mountpoint,usage.percent),
        secret=args.secret, method='numerical|minlim=0|maxlim=85', urlprefix=args.updateurl,verbose=args.verbose)
        
    # my own hash
    filename=os.path.realpath(__file__)
    sha1=hashlib.sha1(open(filename, 'rb').read()).hexdigest()
    clientversion='{}:{}'.format(version,sha1)
    update(args.textid,prefix+"clientversion",clientversion,
        details='',secret=args.secret,
        method='streqd|str={}'.format(clientversion),
        urlprefix=args.updateurl,
        verbose=args.verbose)

    # save cache
    with open(cachepath,"w") as f:
        cachejson = json.dumps(cache, indent=4)
        f.write(cachejson)
    
    
    sys.exit(0)
    
else:
    if args.verbose:
        print "single indicator mode"    
    if not (args.name and args.status):
        print "required indicator name (-n) and status (-s)"
        sys.exit(1)  
    update(args.textid, args.name, args.status, details=args.details,
        secret=args.secret, method=args.method, urlprefix=args.updateurl, verbose=args.verbose)      
        
